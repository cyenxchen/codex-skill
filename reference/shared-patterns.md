# Codex 协作共享模式

本文档定义了所有 Codex 协作命令共享的核心规则、工作流程和模式。

## 核心规则

以下5条规则适用于所有 Codex 协作场景，必须严格遵守：

### 1. 先自检再调用
必须先输出你自己的初步分析（关键要点），再调用 Codex。这确保了独立思考和双重验证。

### 2. 信息不足时提问
若路径、审查范围、需求目标或问题症状不明确，先追问用户，获得足够信息后再继续。

### 3. 安全调用
调用 `mcp__codex__codex` 必须使用 `sandbox="read-only"`，确保 Codex 无法修改文件系统。

### 4. 只读输出
要求 Codex 仅给出以下形式的建议，不做真实修改：
- **Unified diff patch** 格式的代码修改建议
- **问题清单** 和 **分析报告**
- 若上下文不足，先请求文件路径或给出要点级建议

### 5. 质疑验证
对 Codex 的结论必须进行交叉验证，明确指出：
- 不同意的点
- 不确定的点
- 需要更多证据的点

## SESSION_ID 管理

### 会话类型

#### 开启新会话
不传 `SESSION_ID` 参数或传入空值，Codex 会创建新的对话会话。

#### 继续会话
从用户参数中解析 `session=<id>`，将 `SESSION_ID` 传入 `mcp__codex__codex` 工具，继续之前的对话。

### 会话输出规范

每次调用 Codex 后，必须在输出中包含：
```
Codex session: <SESSION_ID>
```

并告知用户可以使用此 ID 继续会话，例如：
```
继续此会话：/codex-review src/app.py session=019ba7a9-8b52-7723-971c-90454123c715
```

## 计划文档集成

在执行 Codex 协作命令时，支持自动检测或手动指定计划文档，为 Codex 提供更丰富的上下文。

### 计划文件检测

在第一步「确认输入」时，执行计划文件检测：

#### 1. 用户指定优先

若 `$ARGUMENTS` 包含 `plan=<path>`：
- 使用 Read 工具验证文件存在
- `plan=none` 表示禁用自动检测

#### 2. 自动检测

若未指定 plan 参数：
1. 使用 Glob 搜索 `.claude/plans/*.md`
2. 若找到文件，按修改时间排序，取最近的一个
3. **使用 Read 读取计划内容，判断与当前任务的相关性**
   - 相关：计划主题、文件/模块、验收标准与当前任务匹配
   - 不相关：跳过，不传递给 Codex
4. 若相关，记录绝对路径

#### 3. 无计划文件

正常执行工作流，不传递计划上下文。

### 传递方式

**只传递文件路径**，让 Codex 自行读取：

```
实现计划上下文：请读取 <plan_absolute_path> 获取完整计划。
```

不要将计划内容读出来塞给 Codex。

### 各场景的计划用途

| 场景 | 计划用途 |
|------|---------|
| 代码审查 | 对照计划中的验收标准、检查实现是否符合预期 |
| 需求分析 | 基于已有计划补充优化，而非从头规划 |
| Debug 定位 | 读取已排查的假设，避免重复验证 |

## 标准工作流程

所有 Codex 协作命令遵循以下6步工作流程：

### 第一步：确认输入

解析 `$ARGUMENTS` 获取任务相关信息：
- 文件路径、代码范围或 git diff
- 需求目标或问题症状
- 可选参数（如 `focus`、`session`、`plan`）

**计划文件检测**（按优先级）：
1. 若 `plan=<path>`：验证并使用指定的计划文件
2. 若 `plan=none`：跳过计划检测
3. 否则：使用 Glob 搜索 `.claude/plans/*.md`，取最近修改的有效计划文件

**若信息不足，向用户提问后停止，不继续后续步骤。**

### 第二步：收集上下文

使用 `Read`、`Grep`、`Glob`、`Bash(git:*)` 等工具获取相关代码和背景信息：
- 阅读相关文件
- 搜索关键代码
- 查看 git 变更历史
- 了解代码架构和依赖

**计划文件处理**（若检测到计划文件）：
- 使用 Read 工具读取计划文件内容
- 判断计划与当前任务的相关性
- 若相关，记录计划文件的绝对路径（待传递给 Codex）

### 第三步：初步分析（必须输出）

**这一步不能跳过！** 在调用 Codex 前，必须输出你自己的初步判断，包含：
- 问题概述或需求拆解
- 潜在风险点或假设
- 需要重点关注的方面
- 初步的解决思路

### 第四步：调用 Codex

调用 `mcp__codex__codex` 工具，参数设置：

```
- cd: 当前工作目录（通常是项目根目录）
- sandbox: "read-only" (必须)
- SESSION_ID: 从参数解析，若为空则不传（开启新会话）
- PROMPT: 包含任务描述、代码内容和输出要求
- return_all_messages:
  - Debug 场景设为 true（需要详细推理）
  - 其他场景可选（默认 false）
```

### 第五步：质疑与验证

对 Codex 的结论进行审视，回答以下问题：
- 是否有遗漏的问题或需求？
- 是否有误判或错误假设？
- 需要更多证据支持的点？
- 修复方案是否会引入新问题？

### 第六步：输出最终结论

整合你的分析和 Codex 的结论，输出必须包含：
1. **结论概述** - 一句话总结
2. **详细发现** - 问题清单、需求拆解或根因分析
3. **建议修复** - Unified diff patch 格式
4. **质疑与验证** - 你对 Codex 结论的审视结果
5. **计划关联**（若使用了计划文件）- 说明发现与计划的关系
   - 代码审查：哪些验收标准已满足/未满足
   - 需求分析：如何补充/优化原计划
   - Debug：哪些假设已验证/排除
6. **验证步骤** - 测试修复的具体方法
7. **Codex session** - `<SESSION_ID>`（用于后续继续会话）

## Codex 调用模板

### 参数设置规范

```python
mcp__codex__codex(
    cd="当前工作目录路径",
    sandbox="read-only",  # 必须
    SESSION_ID="从参数解析，可选",
    PROMPT="见下方格式",
    return_all_messages=False  # Debug场景设为True
)
```

### PROMPT 格式标准

#### 代码审查场景
```
请审查以下代码：

[若用户指定了 focus 参数，在此说明重点关注维度]
- focus=security: 重点关注安全问题
- focus=perf: 重点关注性能问题
- focus=style: 重点关注代码风格
- 无 focus: 全面审查

[若检测到相关计划文档]
实现计划上下文：请读取 <plan_absolute_path> 获取完整计划。
请参考计划中的验收标准，检查实现是否符合预期。

审查维度：
1. 正确性：逻辑错误、边界条件、异常处理
2. 安全性：注入、越权、敏感信息泄露
3. 性能：复杂度、资源泄漏、阻塞操作
4. 可维护性：命名、结构、重复代码

代码内容：
[插入代码或 diff]

输出要求：
- 问题按严重度排序（Critical > High > Medium > Low）
- 每个问题包含：文件/行号、问题描述、风险说明
- 若有修复建议，仅用 unified diff patch 格式
- 若有计划文档，说明哪些验收标准已满足/未满足
```

#### 需求分析场景
```
请分析以下需求并给出实现计划：

需求目标：[用户需求]
约束条件：[技术约束]
相关代码路径：[相关文件]

[若检测到相关计划文档]
已有计划上下文：请读取 <plan_absolute_path> 获取完整计划。
请基于已有计划进行补充和优化，而非从头规划。重点关注：遗漏的任务、风险评估的补充、验收标准的完善。

输出要求：
1. 需求拆解：将需求分解为具体的功能点
2. 实施计划：
   - 阶段划分
   - 任务列表（含优先级）
   - 依赖关系
3. 风险评估：潜在风险和应对策略
4. 验收标准：如何判断需求完成
5. 若有代码原型，仅用 unified diff patch 格式
6. 若有已有计划，说明补充/优化了哪些内容
```

#### Debug 定位场景
```
请分析以下问题并定位根因：

问题症状：[错误信息/日志]
复现步骤：[如果有]
相关代码路径：[可疑文件]
最近变更：[如果有]

[若检测到相关计划文档]
排查进展上下文：请读取 <plan_absolute_path> 获取完整计划。
请参考已排查的假设和进展，避免重复验证已排除的假设。

输出要求：
1. 根因假设：最可能的原因及支持证据
2. 排查步骤：优先级排序的验证步骤
3. 修复方案：最小修复（unified diff patch 格式）
4. 回归风险：修复可能引入的问题
5. 测试建议：验证修复的测试用例
6. 若有排查计划，说明哪些假设已验证/排除
```

## 标准输出格式

### 输出结构

所有 Codex 协作命令的输出必须包含以下部分：

#### 1. 结论概述
一句话总结主要发现或结论。

#### 2. 详细发现
根据场景类型组织：
- **代码审查**：问题清单（按严重度排序）
- **需求分析**：需求拆解和实施计划
- **Debug**：根因分析和排查步骤

每项发现应包含：
- 文件路径和行号
- 问题或需求描述
- 风险说明或优先级

#### 3. 建议修复
使用 **unified diff patch** 格式给出代码修改建议：

```diff
--- a/src/server.py
+++ b/src/server.py
@@ -10,7 +10,7 @@ def process_data(data):
-    result = data.get('value')
+    result = data.get('value', default_value)
     return result
```

#### 4. 质疑与验证
你对 Codex 结论的审视结果：
- 同意的点
- 不同意的点
- 不确定需要验证的点

#### 5. 验证步骤
具体的测试方法或验证步骤，例如：
- 运行特定的测试用例
- 手动复现场景
- 检查特定的日志输出

#### 6. Codex session
```
Codex session: 019ba7a9-8b52-7723-971c-90454123c715
```

并提示用户如何继续会话。

## 错误处理

### 参数验证错误

当用户提供的参数无效或不完整时：
1. 清楚地说明预期格式
2. 提供正确的示例
3. 列出缺失的必需信息

**示例**：
```
参数错误：缺少审查目标。请提供以下之一：
- 文件路径：/codex-review src/server.py
- git diff：/codex-review git diff
- 最近提交：/codex-review git diff HEAD~1
```

### Codex 调用失败

当 `mcp__codex__codex` 工具调用失败时：

#### 超时错误
```
Codex 调用超时。可能原因：
- 代码量过大，建议缩小范围
- 网络问题，请稍后重试

建议：先审查单个文件或函数，而非整个项目。
```

#### 网络错误
```
Codex 调用失败（网络错误）。
请检查网络连接后重试，或稍后再试。
若有 SESSION_ID，可以使用它继续之前的会话。
```

#### MCP 工具不可用
```
Codex MCP 工具未安装或不可用。
请先安装 CodexMCP：
  claude mcp add codex -s user --transport stdio -- uvx --from git+https://github.com/GuDaStudio/codexmcp.git codexmcp

并确保在 ~/.claude/settings.json 中添加 allow 项。
```

### 文件读取错误

#### 文件不存在
```
文件 {path} 不存在。
请检查路径是否正确，或使用 Glob 搜索相关文件。
```

#### 权限错误
```
无法读取文件 {path}（权限不足）。
请检查文件权限。
```

### SESSION_ID 恢复机制

当用户提供了 SESSION_ID 但会话无法恢复时：
```
无法恢复会话 {SESSION_ID}。可能原因：
- 会话已过期（Codex 会话有效期限制）
- SESSION_ID 格式错误

建议：开启新会话，不传 session 参数。
```

## 使用建议

### 何时使用哪个命令

| 场景 | 推荐命令 | 说明 |
|------|---------|------|
| 检查代码质量 | `/codex-review` | 发现 bugs、安全问题、性能问题 |
| 规划新功能 | `/codex-plan` | 需求分析、任务拆解、实施计划 |
| 定位问题根因 | `/codex-debug` | 分析错误、诊断问题、修复建议 |

### 高效协作技巧

1. **提供足够的上下文**：包含相关文件路径、错误日志、需求描述
2. **明确审查重点**：使用 `focus` 参数指定关注维度
3. **利用会话持久化**：复杂任务分多轮进行，使用 SESSION_ID 继续
4. **质疑 Codex 结论**：始终保持批判性思维，验证建议的合理性

### 最佳实践

- ✅ 先自己分析，再调用 Codex，形成双重验证
- ✅ 使用 unified diff patch，便于应用和审查
- ✅ 明确说明不确定的点，避免误导
- ✅ 保存 SESSION_ID，便于后续继续讨论
- ❌ 不要盲目接受 Codex 的建议
- ❌ 不要跳过初步分析步骤
- ❌ 不要在 sandbox 外运行未验证的代码
